// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: camel_case_types, non_constant_identifier_names, unused_field, unused_element, constant_identifier_names

import 'dart:ffi' as ffi;

/// Bindings to the libz80 emulator core.
class libz80 {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  libz80(ffi.DynamicLibrary dynamicLibrary) : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  libz80.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  /// Execute the next instruction.
  void Z80Execute(
    ffi.Pointer<Z80Context> ctx,
  ) {
    return _Z80Execute(
      ctx,
    );
  }

  late final _Z80ExecutePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<Z80Context>)>>(
          'Z80Execute');
  late final _Z80Execute =
      _Z80ExecutePtr.asFunction<void Function(ffi.Pointer<Z80Context>)>();

  /// Execute enough instructions to use at least tstates cycles.
  /// Returns the number of tstates actually executed.  Note: Resets
  /// ctx->tstates.
  int Z80ExecuteTStates(
    ffi.Pointer<Z80Context> ctx,
    int tstates,
  ) {
    return _Z80ExecuteTStates(
      ctx,
      tstates,
    );
  }

  late final _Z80ExecuteTStatesPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedInt Function(
              ffi.Pointer<Z80Context>, ffi.UnsignedInt)>>('Z80ExecuteTStates');
  late final _Z80ExecuteTStates = _Z80ExecuteTStatesPtr.asFunction<
      int Function(ffi.Pointer<Z80Context>, int)>();

  /// Decode the next instruction to be executed.
  /// dump and decode can be NULL if such information is not needed
  ///
  /// @param dump A buffer which receives the hex dump
  /// @param decode A buffer which receives the decoded instruction
  void Z80Debug(
    ffi.Pointer<Z80Context> ctx,
    ffi.Pointer<ffi.Char> dump,
    ffi.Pointer<ffi.Char> decode,
  ) {
    return _Z80Debug(
      ctx,
      dump,
      decode,
    );
  }

  late final _Z80DebugPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<Z80Context>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>)>>('Z80Debug');
  late final _Z80Debug = _Z80DebugPtr.asFunction<
      void Function(ffi.Pointer<Z80Context>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Char>)>();

  /// Resets the processor.
  void Z80RESET(
    ffi.Pointer<Z80Context> ctx,
  ) {
    return _Z80RESET(
      ctx,
    );
  }

  late final _Z80RESETPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<Z80Context>)>>(
          'Z80RESET');
  late final _Z80RESET =
      _Z80RESETPtr.asFunction<void Function(ffi.Pointer<Z80Context>)>();

  /// Generates a hardware interrupt.
  /// Some interrupt modes read a value from the data bus; this value must be provided in this function call, even
  /// if the processor ignores that value in the current interrupt mode.
  ///
  /// @param value The value to read from the data bus
  void Z80INT(
    ffi.Pointer<Z80Context> ctx,
    int value,
  ) {
    return _Z80INT(
      ctx,
      value,
    );
  }

  late final _Z80INTPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<Z80Context>, byte)>>(
      'Z80INT');
  late final _Z80INT =
      _Z80INTPtr.asFunction<void Function(ffi.Pointer<Z80Context>, int)>();

  /// Generates a non-maskable interrupt.
  void Z80NMI(
    ffi.Pointer<Z80Context> ctx,
  ) {
    return _Z80NMI(
      ctx,
    );
  }

  late final _Z80NMIPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<Z80Context>)>>(
          'Z80NMI');
  late final _Z80NMI =
      _Z80NMIPtr.asFunction<void Function(ffi.Pointer<Z80Context>)>();
}

class __mbstate_t extends ffi.Union {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> __mbstate8;

  @ffi.LongLong()
  external int _mbstateL;
}

class __darwin_pthread_handler_rec extends ffi.Struct {
  external ffi
          .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      __routine;

  external ffi.Pointer<ffi.Void> __arg;

  external ffi.Pointer<__darwin_pthread_handler_rec> __next;
}

class _opaque_pthread_attr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_cond_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_condattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_mutex_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_mutexattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_once_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_rwlock_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([192])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_rwlockattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> __opaque;
}

class _opaque_pthread_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  external ffi.Pointer<__darwin_pthread_handler_rec> __cleanup_stack;

  @ffi.Array.multi([8176])
  external ffi.Array<ffi.Char> __opaque;
}

/// A Z80 register set.
/// An union is used since we want independent access to the high and low bytes of the 16-bit registers.
class Z80Regs extends ffi.Union {
  external UnnamedStruct1 wr;

  external UnnamedStruct2 br;
}

/// Word registers.
class UnnamedStruct1 extends ffi.Struct {
  @ushort()
  external int AF;

  @ushort()
  external int BC;

  @ushort()
  external int DE;

  @ushort()
  external int HL;

  @ushort()
  external int IX;

  @ushort()
  external int IY;

  @ushort()
  external int SP;
}

typedef ushort = ffi.UnsignedShort;

/// Byte registers. Note that SP can't be accessed partially.
class UnnamedStruct2 extends ffi.Struct {
  @byte()
  external int F;

  @byte()
  external int A;

  @byte()
  external int C;

  @byte()
  external int B;

  @byte()
  external int E;

  @byte()
  external int D;

  @byte()
  external int L;

  @byte()
  external int H;

  @byte()
  external int IXl;

  @byte()
  external int IXh;

  @byte()
  external int IYl;

  @byte()
  external int IYh;
}

typedef byte = ffi.UnsignedChar;

/// The Z80 flags
abstract class Z80Flags {
  /// < Carry
  static const int F_C = 1;

  /// < Sub / Add
  static const int F_N = 2;

  /// < Parity / Overflow
  static const int F_PV = 4;

  /// < Reserved
  static const int F_3 = 8;

  /// < Half carry
  static const int F_H = 16;

  /// < Reserved
  static const int F_5 = 32;

  /// < Zero
  static const int F_Z = 64;

  /// < Sign
  static const int F_S = 128;
}

/// A Z80 execution context.
class Z80Context extends ffi.Struct {
  /// < Main register set (R)
  external Z80Regs R1;

  /// < Alternate register set (R')
  external Z80Regs R2;

  /// < Program counter
  @ushort()
  external int PC;

  /// < Refresh
  @byte()
  external int R;

  @byte()
  external int I;

  /// < Interrupt Flipflop 1
  @byte()
  external int IFF1;

  /// < Interrupt Flipflop 2
  @byte()
  external int IFF2;

  /// < Instruction mode
  @byte()
  external int IM;

  external Z80DataIn memRead;

  external Z80DataOut memWrite;

  @ffi.Size()
  external int memParam;

  external Z80DataIn ioRead;

  external Z80DataOut ioWrite;

  @ffi.Size()
  external int ioParam;

  @byte()
  external int halted;

  @ffi.UnsignedInt()
  external int tstates;

  @byte()
  external int nmi_req;

  @byte()
  external int int_req;

  @byte()
  external int defer_int;

  @byte()
  external int int_vector;

  @byte()
  external int exec_int_vector;
}

/// Function type to emulate data read.
typedef Z80DataIn
    = ffi.Pointer<ffi.NativeFunction<byte Function(ffi.Size, ushort)>>;

/// Function type to emulate data write.
typedef Z80DataOut = ffi
    .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Size, ushort, byte)>>;

const int __DARWIN_ONLY_64_BIT_INO_T = 1;

const int __DARWIN_ONLY_UNIX_CONFORMANCE = 1;

const int __DARWIN_ONLY_VERS_1050 = 1;

const int __DARWIN_UNIX03 = 1;

const int __DARWIN_64_BIT_INO_T = 1;

const int __DARWIN_VERS_1050 = 1;

const int __DARWIN_NON_CANCELABLE = 0;

const String __DARWIN_SUF_EXTSN = '\$DARWIN_EXTSN';

const int __DARWIN_C_ANSI = 4096;

const int __DARWIN_C_FULL = 900000;

const int __DARWIN_C_LEVEL = 900000;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int __DARWIN_NO_LONG_LONG = 0;

const int _DARWIN_FEATURE_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_VERS_1050 = 1;

const int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;

const int _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;

const int __has_ptrcheck = 0;

const int __DARWIN_NULL = 0;

const int __PTHREAD_SIZE__ = 8176;

const int __PTHREAD_ATTR_SIZE__ = 56;

const int __PTHREAD_MUTEXATTR_SIZE__ = 8;

const int __PTHREAD_MUTEX_SIZE__ = 56;

const int __PTHREAD_CONDATTR_SIZE__ = 8;

const int __PTHREAD_COND_SIZE__ = 40;

const int __PTHREAD_ONCE_SIZE__ = 8;

const int __PTHREAD_RWLOCK_SIZE__ = 192;

const int __PTHREAD_RWLOCKATTR_SIZE__ = 16;

const int __DARWIN_WCHAR_MAX = 2147483647;

const int __DARWIN_WCHAR_MIN = -2147483648;

const int __DARWIN_WEOF = -1;

const int _FORTIFY_SOURCE = 2;

const int NULL = 0;

const int USER_ADDR_NULL = 0;
